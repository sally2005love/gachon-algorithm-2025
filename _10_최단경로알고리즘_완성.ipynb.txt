{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "7sXVIC8b_48l"
      },
      "source": [
        "#  **ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜**"
      ],
      "id": "7sXVIC8b_48l"
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "D6B9mLPP_48m"
      },
      "source": [
        "------------------------------"
      ],
      "id": "D6B9mLPP_48m"
    },
    {
      "cell_type": "markdown",
      "source": [
        "**(ì½”ë©ì—ì„œ)í•œê¸€ í°íŠ¸ ì§€ì •í•˜ëŠ” ë°©ë²•**"
      ],
      "metadata": {
        "id": "Uzqyux7fJbNn"
      },
      "id": "Uzqyux7fJbNn"
    },
    {
      "cell_type": "code",
      "source": [
        "!sudo apt-get install -y fonts-nanum\n",
        "!sudo fc-cache -fv\n",
        "!rm ~/.cache/matplotlib -rf\n",
        "\n",
        "# ì½”ë©ì—ì„œ ìœ„ ì½”ë“œë¥¼ ì‹¤í–‰ì‹œí‚¨ í›„  ë°˜ë“œì‹œ ì½”ë© ë©”ë‰´: \"ëŸ°íƒ€ì„>ì„¸ì…˜ ë‹¤ì‹œ ì‹œì‘\" í•©ë‹ˆë‹¤."
      ],
      "metadata": {
        "collapsed": true,
        "id": "A_oQRimiJPhf"
      },
      "execution_count": null,
      "outputs": [],
      "id": "A_oQRimiJPhf"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "202a6c9f-65da-4abc-a172-a7438e240482",
      "metadata": {
        "id": "202a6c9f-65da-4abc-a172-a7438e240482"
      },
      "outputs": [],
      "source": [
        "# korean font\n",
        "# Colab: NanumGothic, Mac: AppleGothic, ìœˆë„ìš°: Malgun Gothic\n",
        "fontname = 'NanumGothic'\n",
        "import matplotlib.pyplot as plt\n",
        "plt.rcParams.update({'font.family': fontname,        # (ì½”ë©)í•œê¸€ í°íŠ¸\n",
        "                     'font.size': 12,\n",
        "                     'figure.figsize': (5, 3),\n",
        "                     'axes.unicode_minus':  False }) # í°íŠ¸ ì„¤ì •\n",
        "\n",
        "figsize = (5, 3)"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "- **(ì½”ë©ì—ì„œ)ê·¸ë˜í”„ ì‹œê°í™”ë¥¼ ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜**--"
      ],
      "metadata": {
        "id": "bzsfMju5e8v1"
      },
      "id": "bzsfMju5e8v1"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": true,
        "id": "rQucFStLoSKJ"
      },
      "outputs": [],
      "source": [
        "!pip install networkx"
      ],
      "id": "rQucFStLoSKJ"
    },
    {
      "cell_type": "markdown",
      "id": "d9719ece",
      "metadata": {
        "id": "d9719ece"
      },
      "source": [
        "------------------------------"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "**êµµì€ í…ìŠ¤íŠ¸**# 1.ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜(Shortest Path Algorithms)"
      ],
      "metadata": {
        "id": "Rmy11KrcAs0n"
      },
      "id": "Rmy11KrcAs0n"
    },
    {
      "cell_type": "markdown",
      "source": [
        "- ë‘ ì§€ì  ì‚¬ì´ì˜ ê°€ì¥ ì§§ì€ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜\n",
        "- **ê·¸ë˜í”„**ì—ì„œ ë‘ ì •ì  ì‚¬ì´ì˜ **ìµœë‹¨ ê²½ë¡œ**ë¥¼ ì°¾ëŠ”ë‹¤.  \n",
        "- **ê°€ì¤‘ì¹˜ ê·¸ë˜í”„**ì—ì„œ ë‘ ì •ì  ì‚¬ì´ì˜ **ìµœì†Œ ê°€ì¤‘ì¹˜ ê²½ë¡œ**ë¥¼ ì°¾ëŠ”ë‹¤"
      ],
      "metadata": {
        "id": "n-QzqM_nCrU9"
      },
      "id": "n-QzqM_nCrU9"
    },
    {
      "cell_type": "markdown",
      "id": "3736a7f4-d492-4ea6-8291-c856f16523f4",
      "metadata": {
        "id": "3736a7f4-d492-4ea6-8291-c856f16523f4"
      },
      "source": [
        "-----"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "61290070-d884-4751-8b18-42a9668202d6",
      "metadata": {
        "id": "61290070-d884-4751-8b18-42a9668202d6"
      },
      "source": [
        "# **2.Dijkstra's Algorithm**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5f415586-228c-42e5-a45f-0565b2b37d4a",
      "metadata": {
        "jp-MarkdownHeadingCollapsed": true,
        "id": "5f415586-228c-42e5-a45f-0565b2b37d4a"
      },
      "source": [
        "## 2-1.ê°œìš”\n",
        "ìµœë‹¨ ê²½ë¡œ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ê·¸ë˜í”„ ì´ë¡ ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜\n",
        "* **ê°€ì¤‘ì¹˜ ê·¸ë˜í”„** : ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 0 ì´ìƒì¸ ê·¸ë˜í”„ì—ì„œ ì‘ë™.\n",
        "* **ë‹¨ì¼ ì¶œë°œì ** : ì£¼ì–´ì§„ ì‹œì‘ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤.\n",
        "* **ê·¸ë¦¬ë””(Greedy) ì•Œê³ ë¦¬ì¦˜** : í•­ìƒ í˜„ì¬ ìƒí™©ì—ì„œ ìµœì ì´ë¼ê³  ìƒê°ë˜ëŠ” ì„ íƒì„ í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°\n",
        "* **ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê²½ìš° ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ** : ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê²½ìš°ì—ëŠ” ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©)\n",
        "* **íš¨ìœ¨ì„±** :\n",
        "    - ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜ìœ¼ ì‹œê°„ ë³µì¡ë„ O(ğ‘‰^2)\n",
        "    - **í™**(ìš°ì„ ìˆœìœ„ í)ì„ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•˜ë©´ ì‹œê°„ ë³µì¡ë„ê°€ O((V + E) log V)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "d392b888-57f3-427c-807e-fa0794bb6429",
      "metadata": {
        "id": "d392b888-57f3-427c-807e-fa0794bb6429"
      },
      "source": [
        "## 2-2.ë™ì‘ ì›ë¦¬\n",
        "1. ì´ˆê¸°í™”:\n",
        "    - â‘  ëª¨ë“  ë…¸ë“œì˜ ê±°ë¦¬ë¥¼ ë¬´í•œëŒ€ë¡œ ì„¤ì •í•˜ê³ \n",
        "    - â‘¡ ì‹œì‘ ë…¸ë“œì˜ ê±°ë¦¬ëŠ” 0ìœ¼ë¡œ ì„¤ì •,\n",
        "    - â‘¢ ë°©ë¬¸í•œ ë…¸ë“œ ì§‘í•©ê³¼ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì§‘í•© ìƒì„±\n",
        "2. ìµœë‹¨ ê±°ë¦¬ ë…¸ë“œ ì„ íƒ:\n",
        "    - â‘  í˜„ì¬ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ í˜„ì¬ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ê°€ ìµœì†Œì¸ ë…¸ë“œë¥¼ ì„ íƒ\n",
        "3. ê±°ë¦¬ ê°±ì‹ :\n",
        "    - â‘  ì„ íƒëœ ë…¸ë“œë¥¼ ë°©ë¬¸í•œ ë…¸ë“œ ì§‘í•©ì— ì¶”ê°€í•˜ê³ \n",
        "    - â‘¡ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì§‘í•©ì—ì„œ ì œê±°,\n",
        "    - â‘¢ ì„ íƒëœ ë…¸ë“œë¥¼ ê±°ì³ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ê³ ,\n",
        "    - â‘£ í˜„ì¬ ì•Œê³  ìˆëŠ” ê±°ë¦¬ë³´ë‹¤ ì§§ìœ¼ë©´ í•´ë‹¹ ë…¸ë“œì˜ ê±°ë¦¬ë¥¼ ê°±ì‹ í•œë‹¤.\n",
        "4. ë°˜ë³µ:\n",
        "    - â‘  2ë²ˆê³¼ 3ë²ˆ ê³¼ì •ì„ ëª¨ë“  ë…¸ë“œê°€ ë°©ë¬¸ ëœ ë…¸ë“œ ì§‘í•©ì— ì¶”ê°€ë  ë•Œê¹Œì§€ ë°˜ë³µ"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "503ecf23-9311-4989-ac22-1614858ed6ac",
      "metadata": {
        "id": "503ecf23-9311-4989-ac22-1614858ed6ac"
      },
      "source": [
        "## 2-3.ì½”ë“œ"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "7f6b59cb-55cf-4d7f-87cf-c705bb63dbf1",
      "metadata": {
        "id": "7f6b59cb-55cf-4d7f-87cf-c705bb63dbf1"
      },
      "source": [
        "- í™(Heap)ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  êµ¬í˜„"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "ee4c51c0-177b-4bc7-8c9a-788fda2afd97",
      "metadata": {
        "id": "ee4c51c0-177b-4bc7-8c9a-788fda2afd97"
      },
      "outputs": [],
      "source": [
        "import networkx as nx\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "# ìµœë‹¨ ê±°ë¦¬ ì¶œë ¥\n",
        "def print_distance(distances, start):\n",
        "        print(f\"Node Distance from Start({start})\")\n",
        "        for node in distances:\n",
        "            print(f\"{node}\\t\\t{distances[node]}\")\n",
        "\n",
        "# ìµœë‹¨ ê²½ë¡œ&ê±°ë¦¬ ì¶œë ¥\n",
        "def print_paths(shortest_path_tree, start, distances):\n",
        "    def build_path(node):\n",
        "        path = []\n",
        "        while node is not None:\n",
        "            path.append(node)\n",
        "            node = shortest_path_tree[node]\n",
        "        return list(reversed(path))\n",
        "\n",
        "    print(f\"Shortest Path from Start({start}):\")\n",
        "    for node in shortest_path_tree:\n",
        "        if node != start:\n",
        "            path = build_path(node)\n",
        "            print(f\"{start} â†’ {node} ê²½ë¡œ: {' â†’ '.join(path)} ({distances[node]}) \")\n",
        "\n",
        "\n",
        "def draw_graph(graph, shortest_path_tree, start, pos=False):\n",
        "    G = nx.DiGraph()\n",
        "    for node in graph:\n",
        "        for neighbor, weight in graph[node].items():\n",
        "            if weight != float('inf'):\n",
        "                G.add_edge(node, neighbor, weight=weight)\n",
        "\n",
        "    if not pos:\n",
        "        pos = nx.spring_layout(G)\n",
        "    labels = nx.get_edge_attributes(G, 'weight')\n",
        "\n",
        "    plt.figure(figsize=(6, 4))\n",
        "    nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=1000,\n",
        "            font_size=12, font_weight='bold', arrows=True)\n",
        "    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_size=12, label_pos=0.7)   # ê°„ì„  ìœ„ìª½(0.5ê°€ ì¤‘ì•™, 0.7ì€ ìœ„ìª½))\n",
        "\n",
        "    # Highlight the shortest path tree\n",
        "    if start in shortest_path_tree.values():\n",
        "        path_edges = [(shortest_path_tree[node], node) for node in shortest_path_tree if shortest_path_tree[node]]\n",
        "        # nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='r', width=2.5)\n",
        "        # í™”ì‚´í‘œ í‘œì‹œí•˜ê³  ì‹¶ì€ ê²½ìš°: arrows=True, arrowstyle='-|>',arrowsize=20\n",
        "        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='r', width=2.5,\n",
        "                               arrows=True, arrowstyle='-|>',arrowsize=20) # í™”ì‚´í‘œ\n",
        "                            #   connectionstyle='arc3,rad=0.3')   # ê³¡ì„ \n",
        "\n",
        "    plt.title(\"Graph Visualization with Shortest Path Tree\")\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "def dijkstra(graph, start):\n",
        "    # 1. ì´ˆê¸°í™”\n",
        "    distances = {node: float('inf') for node in graph} # â‘  ëª¨ë“  ë…¸ë“œì˜ ê±°ë¦¬ë¥¼ ë¬´í•œëŒ€ë¡œ ì„¤ì •í•˜ê³ \n",
        "    distances[start] = 0            # â‘¡ ì‹œì‘ ë…¸ë“œì˜ ê±°ë¦¬ëŠ” 0ìœ¼ë¡œ ì„¤ì •\n",
        "    visited = set()                 # â‘¢ ë°©ë¬¸í•œ ë…¸ë“œ ì§‘í•©ê³¼ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì§‘í•© ìƒì„±\n",
        "    not_visited = set(graph.keys())\n",
        "    shortest_path_tree = {node: None for node in graph}  # ì‹œê°í™”ë¥¼ ìœ„í•œ ìµœë‹¨ ê±°ë¦¬ íŒ¨ìŠ¤ ê²½ë¡œ ì •ë³´\n",
        "\n",
        "    # 4. ë°˜ë³µ\n",
        "    while not_visited:\n",
        "        # 2. ìµœë‹¨ ê±°ë¦¬ ë…¸ë“œ ì„ íƒ\n",
        "        current_node = min(not_visited, key=lambda node: distances[node]) # â‘  í˜„ì¬ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ í˜„ì¬ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ê°€ ìµœì†Œì¸ ë…¸ë“œë¥¼ ì„ íƒ\n",
        "\n",
        "        # 3. ê±°ë¦¬ ê°±ì‹ \n",
        "        visited.add(current_node)            # â‘  ì„ íƒëœ ë…¸ë“œë¥¼ ë°©ë¬¸í•œ ë…¸ë“œ ì§‘í•©ì— ì¶”ê°€í•˜ê³ \n",
        "        not_visited.remove(current_node)     # â‘¡ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì§‘í•©ì—ì„œ ì œê±°\n",
        "        for neighbor in graph[current_node]: # â‘¢ ì„ íƒëœ ë…¸ë“œë¥¼ ê±°ì³ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ê³ \n",
        "            new_distance = distances[current_node] + graph[current_node][neighbor]\n",
        "            if new_distance < distances[neighbor]:  # â‘£ í˜„ì¬ ì•Œê³  ìˆëŠ” ê±°ë¦¬ë³´ë‹¤ ì§§ìœ¼ë©´ í•´ë‹¹ ë…¸ë“œì˜ ê±°ë¦¬ë¥¼ ê°±ì‹ \n",
        "                distances[neighbor] = new_distance\n",
        "                shortest_path_tree[neighbor] = current_node  # ì‹œê°í™” í•˜ê¸° ìœ„í•´ ìµœë‹¨ ê±°ë¦¬ íŒ¨ìŠ¤ ê²½ë¡œ ì¶”ê°€\n",
        "\n",
        "    return distances, shortest_path_tree\n",
        "\n",
        "\n",
        "# ê·¸ë˜í”„ ë°ì´í„° ìƒì„±(ë”•ì…”ë„ˆë¦¬ ë°ì´í„°)\n",
        "def create_graph_from_edges(edges):\n",
        "    graph = {}\n",
        "    for u, v, w in edges:\n",
        "        if u not in graph:\n",
        "            graph[u] = {}\n",
        "        graph[u][v] = w\n",
        "        # ë‹¨ë°©í–¥ ê·¸ë˜í”„ì´ë¯€ë¡œ ì—­ë°©í–¥ ì¶”ê°€ X\n",
        "        if v not in graph:\n",
        "            graph[v] = {}  # ë…¸ë“œê°€ ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë„ ë¹ˆ ë”•ì…”ë„ˆë¦¬ë¡œ ì´ˆê¸°í™”\n",
        "    return graph\n",
        "\n",
        "\n",
        "\n",
        "# 1. ì—£ì§€ ë¦¬ìŠ¤íŠ¸ ì •ì˜\n",
        "edges = [\n",
        "    ('A', 'B', 11), ('A', 'C', 8), ('A', 'D', 9),\n",
        "    ('B', 'E', 8), ('B', 'G', 8),\n",
        "    ('C', 'F', 10),\n",
        "    ('D', 'B', 3), ('D', 'C', 6),('D', 'F', 1),\n",
        "    ('E', 'G', 7),\n",
        "    ('F', 'H', 2),\n",
        "    ('G', 'D', 12), ('G', 'H', 5),\n",
        "    ('H', 'E', 4)\n",
        "]\n",
        "START = 'A'\n",
        "\n",
        "# 2. ê·¸ë˜í”„ ìƒì„± í•¨ìˆ˜ í˜¸ì¶œ\n",
        "graph = create_graph_from_edges(edges)\n",
        "print(graph)\n",
        "\n",
        "\n",
        "# 3. ë‹¤ìµìŠ¤íŠ¸ë¼ ì‹¤í–‰ ë° ì‹œê°í™” (ì‹œì‘ ì •ì ì—ì„œ ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°)\n",
        "distances, shortest_path_tree = dijkstra(graph, START)\n",
        "\n",
        "print('distances: ', distances) # ì¶œë°œì -->ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ì¶œë ¥\n",
        "print_distance(distances, START)       # ì„¸ë¡œ ì¶œë ¥\n",
        "print()\n",
        "print(\"Shortest Path Tree:\", shortest_path_tree) # ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ ì¶œë ¥\n",
        "print_paths(shortest_path_tree, START, distances)             # ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ë¥¼ ì´ìš©í•˜ì—¬ ì¶œë°œì  --> ë…¸ë“œê¹Œì§€ì˜ ê²½ë¡œ ì¶œë ¥\n",
        "\n",
        "\n",
        "# 4. ìœ„ì¹˜ ì •ë³´ ë° ì‹œê°í™”\n",
        "pos = {\n",
        "    'A': (-1,1),\n",
        "    'B': (-1,-1),\n",
        "    'C': (0,2),\n",
        "    'D': (0,0),\n",
        "    'E': (0,-2),\n",
        "    'F': (1,1),\n",
        "    'G': (1,-1),\n",
        "    'H': (2,0)\n",
        "}\n",
        "draw_graph(graph, shortest_path_tree, START, pos)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "7aab1d0a-42b3-46ac-8f18-61aa850a2921",
      "metadata": {
        "id": "7aab1d0a-42b3-46ac-8f18-61aa850a2921"
      },
      "source": [
        "- í™(heap)ì„ ì´ìš©í•œ ë°©ë²•"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f02013d9-ef83-41b9-b19f-e7138d27b269",
      "metadata": {
        "id": "f02013d9-ef83-41b9-b19f-e7138d27b269"
      },
      "outputs": [],
      "source": [
        "import heapq\n",
        "\n",
        "def heap_dijkstra(graph, start):\n",
        "    # ìš°ì„ ìˆœìœ„ í ì´ˆê¸°í™”: (ê±°ë¦¬, ì •ì )\n",
        "    priority_queue = [(0, start)]\n",
        "    # ì‹œì‘ ì •ì ì—ì„œ ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì €ì¥í•˜ëŠ” ë”•ì…”ë„ˆë¦¬ ì´ˆê¸°í™”\n",
        "    distances = {node: float('infinity') for node in graph}\n",
        "    distances[start] = 0\n",
        "    shortest_path_tree = {node: None for node in graph}\n",
        "\n",
        "    while priority_queue:\n",
        "        # í˜„ì¬ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ì™€ í˜„ì¬ ì •ì ì„ ìš°ì„ ìˆœìœ„ íì—ì„œ ì¶”ì¶œ\n",
        "        current_distance, current_node = heapq.heappop(priority_queue)\n",
        "\n",
        "        # ì´ë¯¸ ì°¾ì€ ìµœë‹¨ ê±°ë¦¬ë³´ë‹¤ í˜„ì¬ ê±°ë¦¬ê°€ ë” ê¸¸ë‹¤ë©´ ë¬´ì‹œ\n",
        "        if current_distance > distances[current_node]:\n",
        "            continue\n",
        "\n",
        "        # í˜„ì¬ ì •ì ê³¼ ì¸ì ‘í•œ ëª¨ë“  ì •ì ì„ í™•ì¸\n",
        "        for neighbor, weight in graph[current_node].items():\n",
        "            distance = current_distance + weight\n",
        "\n",
        "            # í˜„ì¬ ê²½ë¡œê°€ ë” ì§§ì€ ê²½ìš°ì—ë§Œ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê°±ì‹ \n",
        "            if distance < distances[neighbor]:\n",
        "                distances[neighbor] = distance\n",
        "                shortest_path_tree[neighbor] = current_node\n",
        "                heapq.heappush(priority_queue, (distance, neighbor))\n",
        "\n",
        "    return distances, shortest_path_tree\n",
        "\n",
        "# ì‹œì‘ ì •ì ì—ì„œ ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°\n",
        "distances, shortest_path_tree = heap_dijkstra(graph, START)\n",
        "print('distances: ', distances) # ì¶œë°œì -->ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ì¶œë ¥\n",
        "print_distance(distances, START)       # ì„¸ë¡œ ì¶œë ¥\n",
        "print()\n",
        "print(\"Shortest Path Tree:\", shortest_path_tree) # ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ ì¶œë ¥\n",
        "print_paths(shortest_path_tree, START, distances)             # ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ë¥¼ ì´ìš©í•˜ì—¬ ì¶œë°œì  --> ë…¸ë“œê¹Œì§€ì˜ ê²½ë¡œ ì¶œë ¥\n",
        "\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™”\n",
        "draw_graph(graph, shortest_path_tree, START, pos)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cee2a2c9-073f-45e0-8962-459a5e3959f8",
      "metadata": {
        "id": "cee2a2c9-073f-45e0-8962-459a5e3959f8"
      },
      "source": [
        "-----------------------"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "4ff6b43c-1511-4ba8-932e-9f40e74c732b",
      "metadata": {
        "id": "4ff6b43c-1511-4ba8-932e-9f40e74c732b"
      },
      "source": [
        "# **3.Bellman-Ford Algorithm**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "42a91a04-10a6-4170-99f0-7f4188e0942c",
      "metadata": {
        "id": "42a91a04-10a6-4170-99f0-7f4188e0942c"
      },
      "source": [
        "## 3-1.ê°œìš”"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ff01b7e0-ab90-42e5-963f-4336e1abd01b",
      "metadata": {
        "id": "ff01b7e0-ab90-42e5-963f-4336e1abd01b"
      },
      "source": [
        "* **í•µì‹¬ ì•„ì´ë””ì–´** : ê·¸ë˜í”„ì˜ ëª¨ë“  ê°„ì„ ì„ ë°˜ë³µì ìœ¼ë¡œ ì™„í™”(relax)í•˜ì—¬, íŠ¹ì • ì‹œì‘ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ê²ƒ. ìŒìˆ˜ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê·¸ë˜í”„ì—ì„œë„ ì‘ë™í•˜ë©°, ìŒìˆ˜ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš° ì´ë¥¼ íƒì§€í•  ìˆ˜ ìˆë‹¤.\n",
        "* ì—°ì‚° ê³¼ì •: ê°„ì„  ì™„í™”ëŠ” ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì  ê°„ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê°±ì‹ í•˜ëŠ” ê³¼ì •\n",
        "(ëª¨ë“  ê°„ì„ ì„ ìˆœíšŒí•˜ë©°, í˜„ì¬ ê±°ë¦¬ë³´ë‹¤ ë” ì§§ì€ ê²½ë¡œê°€ ìˆë‹¤ë©´ distances ë°°ì—´ì„ ì—…ë°ì´íŠ¸)\n",
        "* ì‹œê°„ ë³µì¡ë„: ì‹œê°„ ë³µì¡ë„ O(Vğ¸)\n",
        "* ì¤‘ìš” íŠ¹ì§• ìš”ì†Œ\n",
        "    - **ìŒì˜ ê°€ì¤‘ì¹˜ í—ˆìš©** : ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ 0 ì´ìƒì¸ ê·¸ë˜í”„ì—ì„œ ì‘ë™.\n",
        "    - **ì‚¬ì´í´ ê°ì§€** : ì£¼ì–´ì§„ ì‹œì‘ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ”ë‹¤.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6eb3e7d2-b9fe-4409-8450-7a5135a07edd",
      "metadata": {
        "id": "6eb3e7d2-b9fe-4409-8450-7a5135a07edd"
      },
      "source": [
        "## 3-2.ë™ì‘ ì›ë¦¬"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "4b1bedcf-c8bc-4a9d-a557-e9e7eca8325c",
      "metadata": {
        "id": "4b1bedcf-c8bc-4a9d-a557-e9e7eca8325c"
      },
      "source": [
        "1. (ê±°ë¦¬)ì´ˆê¸°í™”\n",
        "    - â‘  ëª¨ë“  ë…¸ë“œì˜ ê±°ë¦¬ë¥¼ ë¬´í•œëŒ€ë¡œ ì„¤ì •í•˜ê³ ,\n",
        "    - â‘¡ ì‹œì‘ ë…¸ë“œì˜ ê±°ë¦¬ëŠ” 0ìœ¼ë¡œ ì„¤ì •\n",
        "3. ê°„ì„  ì™„í™”\n",
        "    - â‘  ì „ì²´ ê°„ì„ ì— ëŒ€í•´ì„œ ì‹œí–‰í•œë‹¤.\n",
        "    - â‘¡ í˜„ì¬ ë…¸ë“œ uì˜ ê±°ë¦¬ì— vê¹Œì§€ì˜ ê°„ì„  ê°€ì¤‘ì¹˜ë¥¼ ë”í•œ ê°’ì´ vì˜ í˜„ì¬ ê±°ë¦¬ë³´ë‹¤ ì‘ìœ¼ë©´ vì˜ ê±°ë¦¬ë¥¼ uì˜ ê±°ë¦¬ì— ê°„ì„  ê°€ì¤‘ì¹˜ë¥¼ ë”í•œ ê°’ìœ¼ë¡œ ê°±ì‹ \n",
        "5. ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n",
        "    - â‘  ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ì„œ í•œ ë²ˆ ë” ë°˜ë³µí•˜ì—¬ ê±°ë¦¬ê°€ ê°±ì‹ ë˜ëŠ” ë…¸ë“œê°€ ìˆë‹¤ë©´\n",
        "    - (í˜„ì¬ ë…¸ë“œ uì˜ ê±°ë¦¬ì— vê¹Œì§€ì˜ ê°„ì„  ê°€ì¤‘ì¹˜ë¥¼ ë”í•œ ê°’ì´ vì˜ í˜„ì¬ ê±°ë¦¬ë³´ë‹¤ ì‘ì€ ê²ƒì´ ì¡´ì¬í•˜ë©´) ìŒì˜ ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤ê³  íŒë‹¨í•œë‹¤."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0f8fb7c9-59c6-4c86-bcb0-6c2fcdb2a3f7",
      "metadata": {
        "id": "0f8fb7c9-59c6-4c86-bcb0-6c2fcdb2a3f7"
      },
      "source": [
        "## 3-3.ì½”ë“œ"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cdf9aa15-e538-4b9c-854e-df68c83353b3",
      "metadata": {
        "scrolled": true,
        "id": "cdf9aa15-e538-4b9c-854e-df68c83353b3"
      },
      "outputs": [],
      "source": [
        "def bellman_ford(graph, start):\n",
        "    # 1. ê±°ë¦¬ ì´ˆê¸°í™”\n",
        "    distances = {node: float('inf') for node in graph}\n",
        "    distances[start] = 0\n",
        "    shortest_path_tree = {node: None for node in graph}\n",
        "\n",
        "    # 2. ê°„ì„  ì™„í™”\n",
        "    for i in range(len(graph) - 1):\n",
        "        for u, neighbors in graph.items():\n",
        "            for v, weight in neighbors.items():\n",
        "                new_distance = distances[u] + weight\n",
        "                if new_distance < distances[v]:\n",
        "                    distances[v] = new_distance\n",
        "                    shortest_path_tree[v] = u\n",
        "\n",
        "    # 3.ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n",
        "    for u, neighbors in graph.items():\n",
        "        for v, weight in neighbors.items():\n",
        "            if distances[u] + weight < distances[v]:\n",
        "                return None, None  # Negative cycle detected\n",
        "\n",
        "    return distances, shortest_path_tree\n",
        "\n",
        "\n",
        "# ê·¸ë˜í”„ ìƒì„±(ë”•ì…”ë„ˆë¦¬ ë°ì´í„°)\n",
        "def create_graph_from_edges(edges):\n",
        "    graph = {}\n",
        "    for u, v, w in edges:\n",
        "        if u not in graph:\n",
        "            graph[u] = {}\n",
        "        graph[u][v] = w\n",
        "        # ë‹¨ë°©í–¥ ê·¸ë˜í”„ì´ë¯€ë¡œ ì—­ë°©í–¥ ì¶”ê°€ X\n",
        "        if v not in graph:\n",
        "            graph[v] = {}  # ë…¸ë“œê°€ ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë„ ë¹ˆ ë”•ì…”ë„ˆë¦¬ë¡œ ì´ˆê¸°í™”\n",
        "    return graph\n",
        "\n",
        "\n",
        "# 1. ì—£ì§€ ë¦¬ìŠ¤íŠ¸ ì •ì˜\n",
        "edges = [\n",
        "    ('A', 'B', 11), ('A', 'C', 8), ('A', 'D', 9),\n",
        "    ('B', 'E', 8), ('B', 'G', 8),\n",
        "    ('C', 'F', 10),\n",
        "    ('D', 'B', 3), ('D', 'C', -15),('D', 'F', 1),\n",
        "    ('E', 'G', -7),\n",
        "    ('F', 'H', 2),\n",
        "    ('G', 'D', 12), ('G', 'H', 5),\n",
        "    ('H', 'E', 4)\n",
        "]\n",
        "\n",
        "\n",
        "# 2. ê·¸ë˜í”„ ìƒì„± í•¨ìˆ˜ í˜¸ì¶œ\n",
        "graph = create_graph_from_edges(edges)\n",
        "print(graph)\n",
        "\n",
        "\n",
        "# 3. ë²¨ë§Œí¬ë“œ ì‹¤í–‰ ë° ì‹œê°í™” (ì‹œì‘ ì •ì ì—ì„œ ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°)\n",
        "distances, shortest_path_tree = bellman_ford(graph, START)\n",
        "if distances is None:\n",
        "    print(\"Negative cycle detected\")\n",
        "else:\n",
        "    # print(\"Distances:\", distances)\n",
        "    print_distance(distances, START)\n",
        "\n",
        "print(\"Shortest Path Tree:\", shortest_path_tree) # ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ ì¶œë ¥\n",
        "print_paths(shortest_path_tree, START, distances)# ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ë¥¼ ì´ìš©í•˜ì—¬ ì¶œë°œì  --> ë…¸ë“œê¹Œì§€ì˜ ê²½ë¡œ ì¶œë ¥\n",
        "\n",
        "\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™”\n",
        "pos = {\n",
        "    'A': (-1,1),\n",
        "    'B': (-1,-1),\n",
        "    'C': (0,2),\n",
        "    'D': (0,0),\n",
        "    'E': (0,-2),\n",
        "    'F': (1,1),\n",
        "    'G': (1,-1),\n",
        "    'H': (2,0)\n",
        "}\n",
        "if shortest_path_tree:\n",
        "    draw_graph(graph, shortest_path_tree, START, pos)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c914b79d-6417-4ae0-a9ac-57cc66d0b843",
      "metadata": {
        "id": "c914b79d-6417-4ae0-a9ac-57cc66d0b843"
      },
      "source": [
        "- **Class**ë¥¼ ì´ìš©í•œ ì½”ë“œ"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "fdfaf0e4-87aa-4c01-81fa-82a8152f81cf",
      "metadata": {
        "id": "fdfaf0e4-87aa-4c01-81fa-82a8152f81cf"
      },
      "outputs": [],
      "source": [
        "class Graph:\n",
        "    def __init__(self, nodes):\n",
        "        self.V = nodes  # ì •ì ì˜ ìˆ˜\n",
        "        self.graph = []    # ê·¸ë˜í”„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë¦¬ìŠ¤íŠ¸\n",
        "\n",
        "    # ê°„ì„  ì¶”ê°€\n",
        "    def add_edge(self, u, v, w):\n",
        "        self.graph.append([u, v, w])\n",
        "\n",
        "\n",
        "    # ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°\n",
        "    def bellman_ford(self, start):\n",
        "        # ê±°ë¦¬ ì´ˆê¸°í™”\n",
        "        distance = {node: float('inf') for node in self.nodes}\n",
        "        distance[start] = 0\n",
        "        shortest_path_tree = {node: None for node in self.nodes}\n",
        "\n",
        "        # ê°„ì„  ì™„í™”\n",
        "        for _ in range(self.V - 1):\n",
        "            for u, v, w in self.graph:\n",
        "                if distance[u] != float('inf') and distance[u] + w < distance[v]:\n",
        "                    distance[v] = distance[u] + w\n",
        "                    shortest_path_tree[v] = u\n",
        "\n",
        "        # ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n",
        "        for u, v, w in self.graph:\n",
        "            if distance[u] != float('inf') and distance[u] + w < distance[v]:\n",
        "                print(\"Graph contains negative weight cycle\")\n",
        "                return None, None\n",
        "\n",
        "        return distance, shortest_path_tree\n",
        "\n",
        "    # ê±°ë¦¬ ì¶œë ¥\n",
        "    def print_distance(self, distance, start):\n",
        "        print(f\"node Distance from Start({start})\")\n",
        "        for node in distance:\n",
        "            print(f\"{node}\\t\\t{distance[node]}\")\n",
        "\n",
        "    # ìµœë‹¨ ê²½ë¡œ&ê±°ë¦¬ ì¶œë ¥\n",
        "    def print_paths(self, shortest_path_tree, start, distances):\n",
        "        def build_path(node):\n",
        "            path = []\n",
        "            while node is not None:\n",
        "                path.append(node)\n",
        "                node = shortest_path_tree[node]\n",
        "            return list(reversed(path))\n",
        "\n",
        "        print(f\"Shortest Path from Start({start}):\")\n",
        "        for node in shortest_path_tree:\n",
        "            if node != start:\n",
        "                path = build_path(node)\n",
        "                print(f\"{start} â†’ {node} ê²½ë¡œ: {' â†’ '.join(path)} ({distances[node]}) \")\n",
        "\n",
        "# ê·¸ë˜í”„ ì •ì˜ ë° ê°„ì„  ì¶”ê°€\n",
        "\n",
        "V = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n",
        "g = Graph(len(V))\n",
        "edges = [\n",
        "    ('A', 'B', 11), ('A', 'C', 8), ('A', 'D', 9),\n",
        "    ('B', 'E', 8), ('B', 'G', 8),\n",
        "    ('C', 'F', 10),\n",
        "    ('D', 'B', 3), ('D', 'C', -15),('D', 'F', 1),\n",
        "    ('E', 'G', -7),\n",
        "    ('F', 'H', 2),\n",
        "    ('G', 'D', 12), ('G', 'H', 5),\n",
        "    ('H', 'E', 4)\n",
        "]\n",
        "for u, v, w in edges:\n",
        "    g.add_edge(u, v, w)\n",
        "g.nodes = V\n",
        "\n",
        "# ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰\n",
        "distances, shortest_path_tree = g.bellman_ford(START)\n",
        "if distances is not None and shortest_path_tree is not None:\n",
        "    g.print_distance(distances, START)\n",
        "    g.print_paths(shortest_path_tree, START, distances)# ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ë¥¼ ì´ìš©í•˜ì—¬ ì¶œë°œì  --> ë…¸ë“œê¹Œì§€ì˜ ê²½ë¡œ ì¶œë ¥\n",
        "\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™”\n",
        "if distances is not None and shortest_path_tree is not None:\n",
        "    draw_graph(graph, shortest_path_tree, START, pos)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "33ba76a2-03b8-49e0-8498-4634f9c09ae8",
      "metadata": {
        "id": "33ba76a2-03b8-49e0-8498-4634f9c09ae8"
      },
      "source": [
        "----"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e65382b5-5f08-43dd-ae8c-10cf5b98a514",
      "metadata": {
        "id": "e65382b5-5f08-43dd-ae8c-10cf5b98a514"
      },
      "source": [
        "# **4.Floyd-Warshall Algorithm**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "418265ca-a48e-4165-9b91-c2a33b17a34b",
      "metadata": {
        "id": "418265ca-a48e-4165-9b91-c2a33b17a34b"
      },
      "source": [
        "## 4-1.ê°œìš”"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "- 1962ë…„ì— Robert Floydì™€ Stephen Warshallì— ì˜í•´ ê°œë°œë¨\n",
        "- ëª¨ë“  ì •ì ë“¤ ê°„ì˜ ìƒí˜¸ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ë™ì  í”„ë¡œê·¸ë˜ë° ê¸°ë°˜ì˜ ì•Œê³ ë¦¬ì¦˜\n",
        "- **ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜**ì´Â **í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬**Â ì˜€ë‹¤ë©´,\n",
        "- **í”Œë¡œì´ë“œ ì™€ìƒ¬ ì•Œê³ ë¦¬ì¦˜**ì€Â **ì„ì˜ì˜ ì •ì ì—ì„œ ì„ì˜ì˜ ì •ì ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬**ë¥¼ ë‹¤ë£¨ëŠ” ì•Œê³ ë¦¬ì¦˜\n",
        "    - **ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê²½ìš°ì—ë„ ì‚¬ìš©**í•  ìˆ˜ ìˆì§€ë§Œ, ìŒì˜ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ë©´ ì˜¬ë°”ë¥¸ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ì—†ìŒ"
      ],
      "metadata": {
        "id": "G_HPVttxDnGc"
      },
      "id": "G_HPVttxDnGc"
    },
    {
      "cell_type": "markdown",
      "id": "f535e5df-37fe-48ec-aeb8-8431415c5f9c",
      "metadata": {
        "id": "f535e5df-37fe-48ec-aeb8-8431415c5f9c"
      },
      "source": [
        "## 4-2.ë™ì‘ ì›ë¦¬\n",
        "1. (ê±°ë¦¬)ì´ˆê¸°í™”\n",
        "    - â‘  ê·¸ë˜í”„ ì •ë³´ë¥¼ ê°€ì¤‘ì¹˜ ì¸ì ‘ í–‰ë ¬(ì´ˆê¸° ê±°ë¦¬ í–‰ë ¬)ë¡œ ë§Œë“ ë‹¤.\n",
        "    - â‘¡ ìê¸° ìì‹ ì˜ ê±°ë¦¬ëŠ” 0,  ì—°ê²° ë˜ì§€ ì•Šì€ ë…¸ë“œì˜ ìŒì˜ ê±°ë¦¬ëŠ” ë¬´í•œëŒ€ë¡œ ì„¤ì •í•œë‹¤.\n",
        "2. ì¤‘ê°„ ì •ì  ê³ ë ¤\n",
        "    - â‘  V(ë…¸ë“œê°¯ìˆ˜)ë²ˆ ë°˜ë³µ(ê° ë…¸ë“œ u, v, kì— ëŒ€í•´ â‘¡ë²ˆ ìˆ˜í–‰.)\n",
        "    - â‘¡ í˜„ì¬ uì—ì„œ vê¹Œì§€ì˜ ê²½ë¡œê°€ kë¥¼ ê±°ì³ê°€ëŠ” ê²½ë¡œë³´ë‹¤ ë” ì§§ìœ¼ë©´ uì—ì„œ vê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ kë¥¼ ê±°ì³ê°€ëŠ” ê²½ë¡œì˜ ê±°ë¦¬ë¡œ ê°±ì‹ \n",
        "3. ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n",
        "    - â‘  Vë²ˆì§¸ ë°˜ë³µ í›„ì—ë„ ê±°ë¦¬ê°€ ê°±ì‹ ë˜ëŠ” ë…¸ë“œê°€ ìˆë‹¤ë©´  ìŒì˜ ì‚¬ì´í´ì´ ì¡´ì¬í•œë‹¤ê³  íŒë‹¨í•œë‹¤."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0bcaaf44-aa4e-4a1f-af35-43cf59bbdfde",
      "metadata": {
        "id": "0bcaaf44-aa4e-4a1f-af35-43cf59bbdfde"
      },
      "source": [
        "## 4-3.ì½”ë“œ\n",
        "1. ì—£ì§€ ë¦¬ìŠ¤íŠ¸ ì¤€ë¹„\n",
        "2. create_graph_from_edges(edges) í•¨ìˆ˜ë¡œ graph ìƒì„± (dict ê¸°ë°˜)\n",
        "3. create_adj_matrix(graph)ë¡œ ì¸ì ‘ í–‰ë ¬ ìƒì„±\n",
        "4. floyd_warshall(graph)ëŠ” ì¸ì ‘ í–‰ë ¬ì„ ì‚¬ìš©í•˜ì—¬ ê±°ë¦¬ í–‰ë ¬ ê³„ì‚°\n",
        "5. draw_graph(dist_matrix)ë¡œ ìµœë‹¨ ê±°ë¦¬ ê·¸ë˜í”„ ì‹œê°í™”"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import networkx as nx\n",
        "\n",
        "# ê·¸ë˜í”„ ìƒì„± (ë”•ì…”ë„ˆë¦¬ í˜•íƒœ)\n",
        "def create_graph_from_edges(edges):\n",
        "    graph = {}\n",
        "    for u, v, w in edges:\n",
        "        if u not in graph:\n",
        "            graph[u] = {}\n",
        "        graph[u][v] = w\n",
        "        if v not in graph:\n",
        "            graph[v] = {}\n",
        "    return graph\n",
        "\n",
        "# ì¸ì ‘ í–‰ë ¬ ìƒì„±\n",
        "def create_adj_matrix(graph):\n",
        "    nodes = sorted(graph.keys())\n",
        "    idx = {node: i for i, node in enumerate(nodes)}\n",
        "    n = len(nodes)\n",
        "    matrix = [[float('inf')] * n for _ in range(n)]\n",
        "\n",
        "    for i in range(n):\n",
        "        matrix[i][i] = 0\n",
        "\n",
        "    for u in graph:\n",
        "        for v in graph[u]:\n",
        "            matrix[idx[u]][idx[v]] = graph[u][v]\n",
        "\n",
        "    return matrix, nodes\n",
        "\n",
        "# í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ + ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n",
        "def floyd_warshall(matrix):\n",
        "    n = len(matrix)\n",
        "    dist = [row[:] for row in matrix]\n",
        "\n",
        "    for k in range(n):\n",
        "        for i in range(n):\n",
        "            for j in range(n):\n",
        "                if dist[i][k] != float('inf') and dist[k][j] != float('inf'):\n",
        "                    if dist[i][j] > dist[i][k] + dist[k][j]:\n",
        "                        dist[i][j] = dist[i][k] + dist[k][j]\n",
        "                    # dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n",
        "                    # i â†’ k â†’ jë¥¼ í†µí•´ ê°€ëŠ” ìš°íšŒ ê²½ë¡œ dist[i][k] + dist[k][j] ì¤‘ ë” ì§§ì€ ìª½ì„ ì„ íƒí•˜ë¼\n",
        "\n",
        "    # ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n",
        "    has_negative_cycle = any(dist[i][i] < 0 for i in range(n))\n",
        "    return dist, has_negative_cycle\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™” (ì…ë ¥ ê·¸ë˜í”„)\n",
        "def draw_original_graph(graph, pos=None):\n",
        "    G = nx.DiGraph()\n",
        "    for u in graph:\n",
        "        for v in graph[u]:\n",
        "            G.add_edge(u, v, weight=graph[u][v])\n",
        "\n",
        "    if pos is None:\n",
        "        pos = nx.spring_layout(G)\n",
        "    labels = nx.get_edge_attributes(G, 'weight')\n",
        "    plt.figure(figsize=(6, 4))\n",
        "    nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=1500,\n",
        "            font_size=12, font_weight='bold', arrows=True)\n",
        "    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_size=12)\n",
        "    plt.title(\"Original Graph\")\n",
        "    plt.show()\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™” (ìµœë‹¨ ê±°ë¦¬ ê²°ê³¼)\n",
        "def draw_graph_fw(dist_matrix, nodes, pos=None):\n",
        "    G = nx.DiGraph()\n",
        "    n = len(nodes)\n",
        "    for i in range(n):\n",
        "        for j in range(n):\n",
        "            if i != j and dist_matrix[i][j] != float('inf'):\n",
        "                G.add_edge(nodes[i], nodes[j], weight=dist_matrix[i][j])\n",
        "\n",
        "    if pos is None:\n",
        "        pos = nx.spring_layout(G)\n",
        "    edge_labels = nx.get_edge_attributes(G, 'weight')\n",
        "    plt.figure(figsize=(6, 4))\n",
        "    nx.draw(G, pos, with_labels=True, node_color='lightgreen', node_size=1000,\n",
        "            font_size=12, font_weight='bold', arrows=True)\n",
        "    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12)\n",
        "    plt.title(\"Floyd-Warshall Shortest Path Graph\")\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "edges = [\n",
        "    ('A', 'B', 11), ('A', 'C', 8), ('A', 'D', 9),\n",
        "    ('B', 'E', 8), ('B', 'G', 8),\n",
        "    ('C', 'F', 10),\n",
        "    ('D', 'B', 3), ('D', 'C', -15),('D', 'F', 1),\n",
        "    ('E', 'G', -7),\n",
        "    ('F', 'H', 2),\n",
        "    ('G', 'D', 12), ('G', 'H', 5),\n",
        "    ('H', 'E', 4)\n",
        "]\n",
        "pos = {\n",
        "    'A': (-1,1),\n",
        "    'B': (-1,-1),\n",
        "    'C': (0,2),\n",
        "    'D': (0,0),\n",
        "    'E': (0,-2),\n",
        "    'F': (1,1),\n",
        "    'G': (1,-1),\n",
        "    'H': (2,0)\n",
        "    }\n",
        "\n",
        "\n",
        "graph = create_graph_from_edges(edges)\n",
        "draw_original_graph(graph, pos)\n",
        "\n",
        "adj_matrix, nodes = create_adj_matrix(graph)\n",
        "dist_matrix, has_negative_cycle = floyd_warshall(adj_matrix)\n",
        "\n",
        "# print(\"ìµœë‹¨ ê±°ë¦¬ í–‰ë ¬:\")\n",
        "# for i in range(len(nodes)):\n",
        "#     for j in range(len(nodes)):\n",
        "#         d = dist_matrix[i][j]\n",
        "#         print(f\"{nodes[i]} â†’ {nodes[j]}: {'âˆ' if d == float('inf') else d}\")\n",
        "#     print()\n",
        "\n",
        "if has_negative_cycle:\n",
        "    print(\"âš ï¸ ìŒìˆ˜ ì‚¬ì´í´ì´ ê·¸ë˜í”„ì— ì¡´ì¬í•©ë‹ˆë‹¤.\")\n",
        "else:\n",
        "    print(\"âœ… ìŒìˆ˜ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\")\n",
        "    draw_graph_fw(dist_matrix, nodes, pos)\n"
      ],
      "metadata": {
        "id": "dQEmm5lSSSIt"
      },
      "id": "dQEmm5lSSSIt",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "### **[ì‹¤ìŠµë¬¸ì œ] ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°**\n",
        "í”Œë¡œì´ë“œ-ì™€ìƒ¬ ì•Œê³ ë¦¬ì¦˜ì´ ì ìš©ëœ ê²½ë¡œ ê·¸ë˜í”„ì— ë‹¤ì‹œ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ë‹¤ì‹œ ì ìš©í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•´ ë³´ì‹œì˜¤.\n"
      ],
      "metadata": {
        "id": "3UeAuW_TZc_B"
      },
      "id": "3UeAuW_TZc_B"
    },
    {
      "cell_type": "code",
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import networkx as nx\n",
        "\n",
        "# ==================== ê¸°ì¡´ í•¨ìˆ˜ë“¤ ====================\n",
        "def create_graph_from_edges(edges):\n",
        "    \"\"\"ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¡œë¶€í„° ê·¸ë˜í”„ ë”•ì…”ë„ˆë¦¬ ìƒì„±\"\"\"\n",
        "    graph = {}\n",
        "    for u, v, w in edges:\n",
        "        if u not in graph:\n",
        "            graph[u] = {}\n",
        "        graph[u][v] = w\n",
        "        if v not in graph:\n",
        "            graph[v] = {}\n",
        "    return graph\n",
        "\n",
        "def create_adj_matrix(graph):\n",
        "    \"\"\"ê·¸ë˜í”„ë¥¼ ì¸ì ‘ í–‰ë ¬ë¡œ ë³€í™˜\"\"\"\n",
        "    nodes = sorted(graph.keys())\n",
        "    idx = {node: i for i, node in enumerate(nodes)}\n",
        "    n = len(nodes)\n",
        "    matrix = [[float('inf')] * n for _ in range(n)]\n",
        "\n",
        "    for i in range(n):\n",
        "        matrix[i][i] = 0\n",
        "\n",
        "    for u in graph:\n",
        "        for v in graph[u]:\n",
        "            matrix[idx[u]][idx[v]] = graph[u][v]\n",
        "\n",
        "    return matrix, nodes\n",
        "\n",
        "def floyd_warshall(matrix):\n",
        "    \"\"\"í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ (ëª¨ë“  ìŒ ìµœë‹¨ ê²½ë¡œ)\"\"\"\n",
        "    n = len(matrix)\n",
        "    dist = [row[:] for row in matrix]\n",
        "\n",
        "    for k in range(n):\n",
        "        for i in range(n):\n",
        "            for j in range(n):\n",
        "                if dist[i][k] != float('inf') and dist[k][j] != float('inf'):\n",
        "                    if dist[i][j] > dist[i][k] + dist[k][j]:\n",
        "                        dist[i][j] = dist[i][k] + dist[k][j]\n",
        "\n",
        "    # ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n",
        "    has_negative_cycle = any(dist[i][i] < 0 for i in range(n))\n",
        "    return dist, has_negative_cycle\n",
        "\n",
        "# ==================== ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ ====================\n",
        "def bellman_ford(graph, start_node):\n",
        "    \"\"\"\n",
        "    ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ (ë‹¨ì¼ ì¶œë°œì  ìµœë‹¨ ê²½ë¡œ)\n",
        "\n",
        "    ë§¤ê°œë³€ìˆ˜:\n",
        "        graph: ë”•ì…”ë„ˆë¦¬ í˜•íƒœì˜ ê·¸ë˜í”„ {u: {v: weight}}\n",
        "        start_node: ì¶œë°œ ì •ì \n",
        "\n",
        "    ë°˜í™˜ê°’:\n",
        "        distances: ì‹œì‘ì ìœ¼ë¡œë¶€í„° ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬\n",
        "        has_negative_cycle: ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€\n",
        "        predecessors: ìµœë‹¨ ê²½ë¡œ ì¶”ì ìš© ì´ì „ ì •ì \n",
        "    \"\"\"\n",
        "    # 1ë‹¨ê³„: ëª¨ë“  ì •ì  ìˆ˜ì§‘\n",
        "    nodes = set(graph.keys())\n",
        "    for u in graph:\n",
        "        nodes.update(graph[u].keys())\n",
        "    nodes = sorted(nodes)\n",
        "\n",
        "    # 2ë‹¨ê³„: ê±°ë¦¬ ì´ˆê¸°í™”\n",
        "    distances = {node: float('inf') for node in nodes}\n",
        "    distances[start_node] = 0\n",
        "    predecessors = {node: None for node in nodes}\n",
        "\n",
        "    # 3ë‹¨ê³„: ê°„ì„  ë¦¬ìŠ¤íŠ¸ ìƒì„±\n",
        "    edges = []\n",
        "    for u in graph:\n",
        "        for v in graph[u]:\n",
        "            edges.append((u, v, graph[u][v]))\n",
        "\n",
        "    # 4ë‹¨ê³„: |V| - 1ë²ˆ ë°˜ë³µí•˜ì—¬ ìµœë‹¨ ê±°ë¦¬ ê°±ì‹  (ì´ì™„ ê³¼ì •)\n",
        "    for iteration in range(len(nodes) - 1):\n",
        "        updated = False\n",
        "        for u, v, weight in edges:\n",
        "            # ì´ì™„(Relaxation): ë” ì§§ì€ ê²½ë¡œ ë°œê²¬ ì‹œ ê°±ì‹ \n",
        "            if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n",
        "                distances[v] = distances[u] + weight\n",
        "                predecessors[v] = u\n",
        "                updated = True\n",
        "\n",
        "        # ìµœì í™”: ë” ì´ìƒ ê°±ì‹ ì´ ì—†ìœ¼ë©´ ì¡°ê¸° ì¢…ë£Œ\n",
        "        if not updated:\n",
        "            print(f\"  âœ“ ë²¨ë§Œ-í¬ë“œ: {iteration + 1}ë²ˆì§¸ ë°˜ë³µì—ì„œ ìˆ˜ë ´ ì™„ë£Œ\")\n",
        "            break\n",
        "\n",
        "    # 5ë‹¨ê³„: ìŒìˆ˜ ì‚¬ì´í´ ê°ì§€ (Vë²ˆì§¸ ë°˜ë³µ)\n",
        "    has_negative_cycle = False\n",
        "    for u, v, weight in edges:\n",
        "        if distances[u] != float('inf') and distances[u] + weight < distances[v]:\n",
        "            has_negative_cycle = True\n",
        "            break\n",
        "\n",
        "    return distances, has_negative_cycle, predecessors\n",
        "\n",
        "def bellman_ford_from_matrix(dist_matrix, nodes, start_node):\n",
        "    \"\"\"\n",
        "    í”Œë¡œì´ë“œ-ì›Œì…œ ê²°ê³¼(ê±°ë¦¬ í–‰ë ¬)ì— ë²¨ë§Œ-í¬ë“œ ì ìš©\n",
        "\n",
        "    ê±°ë¦¬ í–‰ë ¬ì„ ê·¸ë˜í”„ë¡œ ë³€í™˜í•œ í›„ ë²¨ë§Œ-í¬ë“œ ì‹¤í–‰\n",
        "    \"\"\"\n",
        "    # ê±°ë¦¬ í–‰ë ¬ì„ ê·¸ë˜í”„ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜\n",
        "    graph = {}\n",
        "    idx = {node: i for i, node in enumerate(nodes)}\n",
        "\n",
        "    for i, u in enumerate(nodes):\n",
        "        graph[u] = {}\n",
        "        for j, v in enumerate(nodes):\n",
        "            # ìê¸° ìì‹ ì´ ì•„ë‹ˆê³ , ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°ë§Œ ì¶”ê°€\n",
        "            if i != j and dist_matrix[i][j] != float('inf'):\n",
        "                graph[u][v] = dist_matrix[i][j]\n",
        "\n",
        "    # ë²¨ë§Œ-í¬ë“œ ì‹¤í–‰\n",
        "    return bellman_ford(graph, start_node)\n",
        "\n",
        "# ==================== ë¹„êµ ë¶„ì„ í•¨ìˆ˜ ====================\n",
        "def compare_algorithms(fw_dist_matrix, nodes, bf_distances, start_node):\n",
        "    \"\"\"í”Œë¡œì´ë“œ-ì›Œì…œê³¼ ë²¨ë§Œ-í¬ë“œ ê²°ê³¼ ë¹„êµ\"\"\"\n",
        "    print(\"\\n\" + \"=\"*80)\n",
        "    print(f\"ğŸ“Š ì•Œê³ ë¦¬ì¦˜ ê²°ê³¼ ë¹„êµ ë¶„ì„ (ì¶œë°œì : {start_node})\")\n",
        "    print(\"=\"*80)\n",
        "\n",
        "    idx = {node: i for i, node in enumerate(nodes)}\n",
        "    start_idx = idx[start_node]\n",
        "\n",
        "    print(f\"\\n{'ëª©ì ì§€':<10} {'í”Œë¡œì´ë“œ-ì›Œì…œ':<20} {'ë²¨ë§Œ-í¬ë“œ':<20} {'ì¼ì¹˜ ì—¬ë¶€':<10}\")\n",
        "    print(\"-\" * 70)\n",
        "\n",
        "    all_match = True\n",
        "    for node in nodes:\n",
        "        fw_dist = fw_dist_matrix[start_idx][idx[node]]\n",
        "        bf_dist = bf_distances[node]\n",
        "\n",
        "        fw_str = 'âˆ' if fw_dist == float('inf') else f\"{fw_dist}\"\n",
        "        bf_str = 'âˆ' if bf_dist == float('inf') else f\"{bf_dist}\"\n",
        "\n",
        "        match = \"âœ…\" if fw_dist == bf_dist else \"âŒ\"\n",
        "        if fw_dist != bf_dist:\n",
        "            all_match = False\n",
        "\n",
        "        print(f\"{node:<10} {fw_str:<20} {bf_str:<20} {match:<10}\")\n",
        "\n",
        "    print(\"-\" * 70)\n",
        "    if all_match:\n",
        "        print(\"âœ… ëª¨ë“  ê²°ê³¼ ì¼ì¹˜! ë‘ ì•Œê³ ë¦¬ì¦˜ì´ ì •í™•íˆ ì‘ë™í•˜ê³  ìˆìŠµë‹ˆë‹¤.\")\n",
        "    else:\n",
        "        print(\"âŒ ê²°ê³¼ ë¶ˆì¼ì¹˜! êµ¬í˜„ì„ í™•ì¸í•´ì£¼ì„¸ìš”.\")\n",
        "    print(\"=\"*80)\n",
        "\n",
        "    return all_match\n",
        "\n",
        "# ==================== ì‹œê°í™” í•¨ìˆ˜ë“¤ ====================\n",
        "def draw_original_graph(graph, pos=None):\n",
        "    \"\"\"ì›ë³¸ ê·¸ë˜í”„ ì‹œê°í™”\"\"\"\n",
        "    G = nx.DiGraph()\n",
        "    for u in graph:\n",
        "        for v in graph[u]:\n",
        "            G.add_edge(u, v, weight=graph[u][v])\n",
        "\n",
        "    if pos is None:\n",
        "        pos = nx.spring_layout(G)\n",
        "    labels = nx.get_edge_attributes(G, 'weight')\n",
        "    plt.figure(figsize=(8, 6))\n",
        "    nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=1500,\n",
        "            font_size=12, font_weight='bold', arrows=True, arrowsize=20)\n",
        "    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_size=10)\n",
        "    plt.title(\"ğŸ“ Original Graph\", fontsize=14, fontweight='bold')\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "def draw_graph_fw(dist_matrix, nodes, pos=None):\n",
        "    \"\"\"í”Œë¡œì´ë“œ-ì›Œì…œ ê²°ê³¼ ê·¸ë˜í”„ ì‹œê°í™” (ì™„ì „ ê·¸ë˜í”„)\"\"\"\n",
        "    G = nx.DiGraph()\n",
        "    n = len(nodes)\n",
        "    for i in range(n):\n",
        "        for j in range(n):\n",
        "            if i != j and dist_matrix[i][j] != float('inf'):\n",
        "                G.add_edge(nodes[i], nodes[j], weight=dist_matrix[i][j])\n",
        "\n",
        "    if pos is None:\n",
        "        pos = nx.spring_layout(G)\n",
        "    edge_labels = nx.get_edge_attributes(G, 'weight')\n",
        "    plt.figure(figsize=(8, 6))\n",
        "    nx.draw(G, pos, with_labels=True, node_color='lightgreen', node_size=1000,\n",
        "            font_size=12, font_weight='bold', arrows=True, arrowsize=20)\n",
        "    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=9)\n",
        "    plt.title(\"ğŸ”· Floyd-Warshall Shortest Path Graph (Complete)\",\n",
        "              fontsize=14, fontweight='bold')\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "def draw_bellman_ford_tree(graph, start_node, distances, predecessors, pos=None):\n",
        "    \"\"\"ë²¨ë§Œ-í¬ë“œ ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ ì‹œê°í™”\"\"\"\n",
        "    G = nx.DiGraph()\n",
        "\n",
        "    # ëª¨ë“  ë…¸ë“œ ì¶”ê°€\n",
        "    for node in distances.keys():\n",
        "        G.add_node(node)\n",
        "\n",
        "    # ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ì˜ ê°„ì„ ë§Œ ì¶”ê°€\n",
        "    for node in distances.keys():\n",
        "        if predecessors[node] is not None:\n",
        "            weight = graph[predecessors[node]][node]\n",
        "            G.add_edge(predecessors[node], node, weight=weight)\n",
        "\n",
        "    if pos is None:\n",
        "        pos = nx.spring_layout(G)\n",
        "\n",
        "    plt.figure(figsize=(8, 6))\n",
        "\n",
        "    # ì‹œì‘ ë…¸ë“œëŠ” ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ê°•ì¡°\n",
        "    node_colors = ['red' if node == start_node else 'lightcoral' for node in G.nodes()]\n",
        "\n",
        "    nx.draw(G, pos, with_labels=True, node_color=node_colors, node_size=1500,\n",
        "            font_size=12, font_weight='bold', arrows=True, arrowsize=20,\n",
        "            edge_color='darkred', width=2)\n",
        "\n",
        "    # ê°„ì„  ë ˆì´ë¸”\n",
        "    edge_labels = nx.get_edge_attributes(G, 'weight')\n",
        "    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=10)\n",
        "\n",
        "    plt.title(f\"ğŸ¯ Bellman-Ford Shortest Path Tree from '{start_node}'\",\n",
        "              fontsize=14, fontweight='bold')\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "# ==================== ë©”ì¸ ì‹¤í–‰ ì½”ë“œ ====================\n",
        "print(\"\\n\" + \"ğŸ”·\" * 40)\n",
        "print(\"   ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ ë¹„êµ ì‹¤í—˜\")\n",
        "print(\"   Floyd-Warshall â†’ Bellman-Ford ì¬ì ìš©\")\n",
        "print(\"ğŸ”·\" * 40 + \"\\n\")\n",
        "\n",
        "# ì›ë³¸ ê·¸ë˜í”„ ì •ì˜\n",
        "edges = [\n",
        "    ('A', 'B', 11), ('A', 'C', 8), ('A', 'D', 9),\n",
        "    ('B', 'E', 8), ('B', 'G', 8),\n",
        "    ('C', 'F', 10),\n",
        "    ('D', 'B', 3), ('D', 'C', -15), ('D', 'F', 1),\n",
        "    ('E', 'G', -7),\n",
        "    ('F', 'H', 2),\n",
        "    ('G', 'D', 12), ('G', 'H', 5),\n",
        "    ('H', 'E', 4)\n",
        "]\n",
        "\n",
        "pos = {\n",
        "    'A': (-1, 1), 'B': (-1, -1), 'C': (0, 2), 'D': (0, 0),\n",
        "    'E': (0, -2), 'F': (1, 1), 'G': (1, -1), 'H': (2, 0)\n",
        "}\n",
        "\n",
        "# STEP 1: ì›ë³¸ ê·¸ë˜í”„ ìƒì„± ë° ì‹œê°í™”\n",
        "print(\"ğŸ“ STEP 1: ì›ë³¸ ê·¸ë˜í”„ ìƒì„± ë° ì‹œê°í™”\")\n",
        "print(\"-\" * 80)\n",
        "graph = create_graph_from_edges(edges)\n",
        "draw_original_graph(graph, pos)\n",
        "\n",
        "# STEP 2: í”Œë¡œì´ë“œ-ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ ì ìš©\n",
        "print(\"\\nğŸ“ STEP 2: Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ ì ìš©\")\n",
        "print(\"-\" * 80)\n",
        "adj_matrix, nodes = create_adj_matrix(graph)\n",
        "fw_dist_matrix, fw_has_negative_cycle = floyd_warshall(adj_matrix)\n",
        "\n",
        "if fw_has_negative_cycle:\n",
        "    print(\"âš ï¸  í”Œë¡œì´ë“œ-ì›Œì…œ: ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬ â†’ ìµœë‹¨ ê²½ë¡œ ì •ì˜ ë¶ˆê°€\")\n",
        "else:\n",
        "    print(\"âœ… í”Œë¡œì´ë“œ-ì›Œì…œ: ìŒìˆ˜ ì‚¬ì´í´ ì—†ìŒ â†’ ëª¨ë“  ìŒ ìµœë‹¨ ê²½ë¡œ ê³„ì‚° ì™„ë£Œ\")\n",
        "    draw_graph_fw(fw_dist_matrix, nodes, pos)\n",
        "\n",
        "# STEP 3: ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ ì ìš© (ì›ë³¸ ê·¸ë˜í”„)\n",
        "print(\"\\nğŸ“ STEP 3: Bellman-Ford ì•Œê³ ë¦¬ì¦˜ ì ìš© (ì›ë³¸ ê·¸ë˜í”„)\")\n",
        "print(\"-\" * 80)\n",
        "start_node = 'A'  # ì¶œë°œ ì •ì \n",
        "print(f\"ì¶œë°œ ì •ì : {start_node}\")\n",
        "\n",
        "bf_distances, bf_has_negative_cycle, bf_predecessors = bellman_ford(graph, start_node)\n",
        "\n",
        "if bf_has_negative_cycle:\n",
        "    print(f\"âš ï¸  ë²¨ë§Œ-í¬ë“œ: ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬ ('{start_node}'ì—ì„œ ë„ë‹¬ ê°€ëŠ¥)\")\n",
        "else:\n",
        "    print(f\"âœ… ë²¨ë§Œ-í¬ë“œ: '{start_node}'ì—ì„œ ìŒìˆ˜ ì‚¬ì´í´ ì—†ìŒ\")\n",
        "    draw_bellman_ford_tree(graph, start_node, bf_distances, bf_predecessors, pos)\n",
        "\n",
        "    print(f\"\\n{start_node}ì—ì„œ ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬:\")\n",
        "    for node in nodes:\n",
        "        dist_str = 'âˆ' if bf_distances[node] == float('inf') else bf_distances[node]\n",
        "        print(f\"  {start_node} â†’ {node}: {dist_str}\")\n",
        "\n",
        "# STEP 4: ì•Œê³ ë¦¬ì¦˜ ê²°ê³¼ ë¹„êµ\n",
        "print(\"\\nğŸ“ STEP 4: ì•Œê³ ë¦¬ì¦˜ ê²°ê³¼ ë¹„êµ (ì›ë³¸ ê·¸ë˜í”„ ê¸°ì¤€)\")\n",
        "print(\"-\" * 80)\n",
        "compare_algorithms(fw_dist_matrix, nodes, bf_distances, start_node)\n",
        "\n",
        "# STEP 5: í”Œë¡œì´ë“œ-ì›Œì…œ ê²°ê³¼ ê·¸ë˜í”„ì— ë²¨ë§Œ-í¬ë“œ ì¬ì ìš©\n",
        "print(\"\\nğŸ“ STEP 5: Floyd-Warshall ê²°ê³¼ ê·¸ë˜í”„ì— Bellman-Ford ì¬ì ìš©\")\n",
        "print(\"-\" * 80)\n",
        "print(\"(ì´ë¯¸ ìµœë‹¨ ê±°ë¦¬ë¡œ ë³€í™˜ëœ ì™„ì „ ê·¸ë˜í”„ì— ë‹¤ì‹œ ì ìš©)\")\n",
        "\n",
        "bf2_distances, bf2_has_negative_cycle, bf2_predecessors = \\\n",
        "    bellman_ford_from_matrix(fw_dist_matrix, nodes, start_node)\n",
        "\n",
        "if bf2_has_negative_cycle:\n",
        "    print(\"âš ï¸  ì¬ì ìš© ë²¨ë§Œ-í¬ë“œ: ìŒìˆ˜ ì‚¬ì´í´ ê°ì§€ (ì´ë¡ ì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥!)\")\n",
        "else:\n",
        "    print(\"âœ… ì¬ì ìš© ë²¨ë§Œ-í¬ë“œ: ìŒìˆ˜ ì‚¬ì´í´ ì—†ìŒ\")\n",
        "\n",
        "# STEP 6: ì¬ì ìš© ê²°ê³¼ ìƒì„¸ ë¹„êµ\n",
        "print(\"\\nğŸ“ STEP 6: ì¬ì ìš© ê²°ê³¼ ìƒì„¸ ë¹„êµ\")\n",
        "print(\"-\" * 80)\n",
        "print(f\"\\n{'ëª©ì ì§€':<10} {'ì›ë³¸ BF':<15} {'ì¬ì ìš© BF':<15} {'í”Œë¡œì´ë“œ-ì›Œì…œ':<18} {'ì¼ì¹˜':<10}\")\n",
        "print(\"-\" * 75)\n",
        "\n",
        "all_match = True\n",
        "for node in nodes:\n",
        "    bf1 = bf_distances[node]\n",
        "    bf2 = bf2_distances[node]\n",
        "    fw = fw_dist_matrix[nodes.index(start_node)][nodes.index(node)]\n",
        "\n",
        "    bf1_str = 'âˆ' if bf1 == float('inf') else f\"{bf1}\"\n",
        "    bf2_str = 'âˆ' if bf2 == float('inf') else f\"{bf2}\"\n",
        "    fw_str = 'âˆ' if fw == float('inf') else f\"{fw}\"\n",
        "\n",
        "    match = \"âœ…\" if (bf1 == bf2 == fw) else \"âŒ\"\n",
        "    if not (bf1 == bf2 == fw):\n",
        "        all_match = False\n",
        "\n",
        "    print(f\"{node:<10} {bf1_str:<15} {bf2_str:<15} {fw_str:<18} {match:<10}\")\n",
        "\n",
        "print(\"-\" * 75)\n",
        "\n",
        "# ìµœì¢… ê²°ë¡ \n",
        "print(\"\\n\" + \"=\"*80)\n",
        "print(\"ğŸ“ ì‹¤í—˜ ê²°ë¡ :\")\n",
        "print(\"=\"*80)\n",
        "\n",
        "if all_match:\n",
        "    print(\"\"\"\n",
        "âœ… ì„¸ ê°€ì§€ ë°©ë²• ëª¨ë‘ ë™ì¼í•œ ê²°ê³¼ë¥¼ ì‚°ì¶œí–ˆìŠµë‹ˆë‹¤!\n",
        "\n",
        "1. í”Œë¡œì´ë“œ-ì›Œì…œ: ëª¨ë“  ìŒ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚° (O(VÂ³))\n",
        "2. ë²¨ë§Œ-í¬ë“œ (ì›ë³¸): ë‹¨ì¼ ì¶œë°œì  ìµœë‹¨ ê±°ë¦¬ ê³„ì‚° (O(VE))\n",
        "3. ë²¨ë§Œ-í¬ë“œ (ì¬ì ìš©): í”Œë¡œì´ë“œ-ì›Œì…œ ê²°ê³¼ì— ì¬ì ìš©\n",
        "\n",
        "ğŸ’¡ í•µì‹¬ ì¸ì‚¬ì´íŠ¸:\n",
        "   - ìµœì í™”ëœ ê²°ê³¼ì— ìµœì í™” ì¬ì ìš© = ë©±ë“±ì„±(Idempotency) í™•ì¸\n",
        "   - ì„œë¡œ ë‹¤ë¥¸ ì•Œê³ ë¦¬ì¦˜ì´ ê°™ì€ ë‹µ = ì •í™•ì„± ê²€ì¦\n",
        "   - í”Œë¡œì´ë“œ-ì›Œì…œ ê²°ê³¼ëŠ” ì´ë¯¸ ì™„ì „ ìµœì í™”ëœ ì™„ì „ ê·¸ë˜í”„\n",
        "\n",
        "ğŸ“š êµìœ¡ì  ê°€ì¹˜:\n",
        "   - ì•Œê³ ë¦¬ì¦˜ ë™ì‘ ì›ë¦¬ ë¹„êµ í•™ìŠµ\n",
        "   - ì‹œê°„/ê³µê°„ ë³µì¡ë„ íŠ¸ë ˆì´ë“œì˜¤í”„ ì´í•´\n",
        "   - ë¬¸ì œì— ë§ëŠ” ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ëŠ¥ë ¥ í–¥ìƒ\n",
        "\"\"\")\n",
        "else:\n",
        "    print(\"âŒ ê²°ê³¼ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. êµ¬í˜„ì„ ì¬í™•ì¸í•´ì£¼ì„¸ìš”.\")\n",
        "\n",
        "print(\"=\"*80 + \"\\n\")"
      ],
      "metadata": {
        "id": "qGtUjYTqXbXE"
      },
      "id": "qGtUjYTqXbXE",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "id": "6bc3fd56-3819-4705-ad97-79d8d4178c0b",
      "metadata": {
        "id": "6bc3fd56-3819-4705-ad97-79d8d4178c0b"
      },
      "source": [
        "-----"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "598b418b-638d-4554-96c9-c88b724f57bb",
      "metadata": {
        "id": "598b418b-638d-4554-96c9-c88b724f57bb"
      },
      "source": [
        "# **5.Best-First-Search**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "a2c9d61c-45f6-47f1-9186-bb2f3502bf43",
      "metadata": {
        "id": "a2c9d61c-45f6-47f1-9186-bb2f3502bf43"
      },
      "source": [
        "## 5-1.8-puzzle problem"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1d351bdd-cb28-4f3a-b880-b81bbf571a91",
      "metadata": {
        "id": "1d351bdd-cb28-4f3a-b880-b81bbf571a91"
      },
      "outputs": [],
      "source": [
        "import heapq\n",
        "\n",
        "class PuzzleState:\n",
        "    def __init__(self, board, move=0, previous=None):\n",
        "        self.board = board\n",
        "        self.move = move\n",
        "        self.previous = previous\n",
        "        self.blank_pos = board.index(0)\n",
        "\n",
        "    def __lt__(self, other):\n",
        "        return self.f() < other.f()\n",
        "\n",
        "    def f(self):\n",
        "        return self.move + self.h()\n",
        "\n",
        "    def h(self):\n",
        "        return sum(abs(b % 3 - g % 3) + abs(b // 3 - g // 3)\n",
        "                   for b, g in ((self.board.index(i), GOAL.index(i)) for i in range(1, 9)))\n",
        "\n",
        "    def possible_moves(self):\n",
        "        moves = []\n",
        "        x, y = divmod(self.blank_pos, 3)\n",
        "        directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n",
        "        for direction, (dx, dy) in directions.items():\n",
        "            nx, ny = x + dx, y + dy\n",
        "            if 0 <= nx < 3 and 0 <= ny < 3:\n",
        "                new_blank_pos = nx * 3 + ny  # 2ì°¨ì› ì¢Œí‘œë¥¼ 1ì°¨ì› ì¸ë±ìŠ¤ë¡œ ë³€í™˜í•˜ëŠ” ìˆ˜ì‹\n",
        "                new_board = self.board[:]\n",
        "                new_board[self.blank_pos], new_board[new_blank_pos] = new_board[new_blank_pos], new_board[self.blank_pos]\n",
        "                moves.append(PuzzleState(new_board, self.move + 1, self))\n",
        "        return moves\n",
        "\n",
        "    def is_goal(self):\n",
        "        return self.board == GOAL\n",
        "\n",
        "    def __str__(self):\n",
        "        return '\\n'.join([' '.join(map(str, self.board[i:i + 3])) for i in range(0, 9, 3)])\n",
        "\n",
        "\n",
        "def best_first_search(initial_state):\n",
        "    open_set = []\n",
        "    heapq.heappush(open_set, initial_state)\n",
        "    closed_set = set()\n",
        "    while open_set:\n",
        "        current_state = heapq.heappop(open_set)\n",
        "        if current_state.is_goal():\n",
        "            return current_state\n",
        "        closed_set.add(tuple(current_state.board))\n",
        "        for move in current_state.possible_moves():\n",
        "            if tuple(move.board) not in closed_set:\n",
        "                heapq.heappush(open_set, move)\n",
        "    return None\n",
        "\n",
        "def a_star_search(initial_state):\n",
        "    open_set = []\n",
        "    heapq.heappush(open_set, initial_state)\n",
        "    closed_set = set()\n",
        "    while open_set:\n",
        "        current_state = heapq.heappop(open_set)\n",
        "        if current_state.is_goal():\n",
        "            return current_state\n",
        "        closed_set.add(tuple(current_state.board))\n",
        "        for move in current_state.possible_moves():\n",
        "            if tuple(move.board) not in closed_set:\n",
        "                heapq.heappush(open_set, move)\n",
        "    return None\n",
        "\n",
        "def reconstruct_path(state):\n",
        "    path = []\n",
        "    while state:\n",
        "        path.append(state)\n",
        "        state = state.previous\n",
        "    return path[::-1]\n",
        "\n",
        "# ì´ˆê¸° ìƒíƒœì™€ ëª©í‘œ ìƒíƒœ\n",
        "initial_board = [1, 2, 3, 7, 4, 5, 0, 8, 6]\n",
        "GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]\n",
        "\n",
        "# ì´ˆê¸° ìƒíƒœ ì„¤ì •\n",
        "initial_state = PuzzleState(initial_board)\n",
        "\n",
        "\n",
        "# Best-First Search ì‹¤í–‰\n",
        "goal_state = best_first_search(initial_state)\n",
        "\n",
        "# # A* ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰\n",
        "# goal_state = a_star_search(initial_state)\n",
        "\n",
        "if goal_state:\n",
        "    path = reconstruct_path(goal_state)\n",
        "    for step, state in enumerate(path):\n",
        "        print(f\"Step {step}:\\n{state}\\n\")\n",
        "else:\n",
        "    print(\"No solution found.\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "2e25f6e5-def8-44cc-9ab5-67f3c0428092",
      "metadata": {
        "id": "2e25f6e5-def8-44cc-9ab5-67f3c0428092"
      },
      "source": [
        "## 5-2. Best-First-Search\n",
        "- **ê·¸ë˜í”„ì—ì„œ A --> H ê¹Œì§€ ê°€ëŠ” ë¹ ë¥¸ ê²½ë¡œ ì°¾ê¸°**"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "40e43fa8-422c-4b47-ba25-e5e46a53978e",
      "metadata": {
        "id": "40e43fa8-422c-4b47-ba25-e5e46a53978e"
      },
      "outputs": [],
      "source": [
        "import heapq\n",
        "import matplotlib.pyplot as plt\n",
        "import networkx as nx\n",
        "\n",
        "\n",
        "# íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ (ë‹¨ìˆœíˆ ì„ì˜ì˜ ê°’ì„ ì‚¬ìš©í•œ ì˜ˆì‹œ)\n",
        "def heuristic(node, goal):\n",
        "    h_values = {\n",
        "        'A': 7, 'B': 6, 'C': 2, 'D': 1,\n",
        "        'E': 1, 'F': 0, 'G': 3, 'H': 4\n",
        "    }\n",
        "    h_values = {\n",
        "        'A': 7, 'B': 6, 'C': 2, 'D': 1,\n",
        "        'E': 1, 'F': 0, 'G': 3, 'H': 0\n",
        "    }\n",
        "    # h_values ê°’ì„ ë³€ê²½í•´ ë³¸ë‹¤.\n",
        "    # h_values = {\n",
        "    #     'A': 10,  # ì„ì˜ì˜ ê°’\n",
        "    #     'B': 6,\n",
        "    #     'C': 6,\n",
        "    #     'D': 7,\n",
        "    #     'E': 4,\n",
        "    #     'F': 2,\n",
        "    #     'G': 3,\n",
        "    #     'H': 0   # ëª©í‘œ ë…¸ë“œì˜ íœ´ë¦¬ìŠ¤í‹± ê°’ì€ 0\n",
        "    # }\n",
        "    return h_values[node]\n",
        "\n",
        "def best_first_search(graph, start, goal):\n",
        "    # ìš°ì„ ìˆœìœ„ í ì´ˆê¸°í™”\n",
        "    priority_queue = []\n",
        "    heapq.heappush(priority_queue, (heuristic(start, goal), start))\n",
        "\n",
        "    # ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ì¶”ì í•˜ê¸° ìœ„í•œ ì§‘í•© ë° ê²½ë¡œ ê¸°ë¡\n",
        "    visited = set()\n",
        "    path = []\n",
        "\n",
        "    while priority_queue:\n",
        "        # ìš°ì„ ìˆœìœ„ íì—ì„œ íœ´ë¦¬ìŠ¤í‹± ê°’ì´ ê°€ì¥ ì‘ì€ ì •ì ì„ ì¶”ì¶œ\n",
        "        _, current_node = heapq.heappop(priority_queue)\n",
        "        path.append(current_node)\n",
        "\n",
        "        # ëª©í‘œ ì •ì ì¸ì§€ ê²€ì‚¬\n",
        "        if current_node == goal:\n",
        "            print(f\"Goal {goal} found!\")\n",
        "            return path\n",
        "\n",
        "        # í˜„ì¬ ë…¸ë“œë¥¼ ë°©ë¬¸í•œ ê²ƒìœ¼ë¡œ í‘œì‹œ\n",
        "        visited.add(current_node)\n",
        "\n",
        "        # ì¸ì ‘ ì •ì  íƒìƒ‰\n",
        "        for neighbor, weight in graph[current_node].items():\n",
        "            if neighbor not in visited:\n",
        "                heapq.heappush(priority_queue, (heuristic(neighbor, goal), neighbor))\n",
        "\n",
        "    print(\"Goal not found.\")\n",
        "    return path\n",
        "\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™” í•¨ìˆ˜\n",
        "def draw_graph(graph, path, pos=False):\n",
        "    G = nx.DiGraph()\n",
        "\n",
        "    # ì›ë˜ ê·¸ë˜í”„ì˜ ê°„ì„  ì¶”ê°€\n",
        "    for u in graph:\n",
        "        for v, weight in graph[u].items():\n",
        "            G.add_edge(u, v, weight=weight)\n",
        "\n",
        "    if not pos: pos = nx.spring_layout(G)\n",
        "    labels = nx.get_edge_attributes(G, 'weight')\n",
        "\n",
        "    plt.figure(figsize=(6, 5))\n",
        "    nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=1000, font_size=15, font_weight='bold', arrows=True)\n",
        "    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)\n",
        "\n",
        "    # íƒìƒ‰ ê²½ë¡œ ê°•ì¡°\n",
        "    if path:\n",
        "        path_edges = [(path[i], path[i+1]) for i in range(len(path)-1)]\n",
        "        nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='r', width=2.5)\n",
        "        nx.draw_networkx_nodes(G, pos, nodelist=path, node_color='orange', node_size=2000)\n",
        "\n",
        "    plt.title(\"Graph Visualization with Best-First Search Path\")\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "# ê·¸ë˜í”„ ì •ì˜ (ì¸ì ‘ ë¦¬ìŠ¤íŠ¸)\n",
        "graph = {\n",
        "    'A': {'B': 11, 'C': 8, 'D': 9},\n",
        "    'B': {'E': 8, 'G': 8},\n",
        "    'C': {'F': 10},\n",
        "    'D': {'B': 3, 'C': -15, 'F': 1},\n",
        "    'E': {'G': -7},\n",
        "    'F': {'H': 2},\n",
        "    'G': {'D': 12, 'H': 5},\n",
        "    'H': {'E': 4}\n",
        "}\n",
        "pos = {\n",
        "    'A': (-1,1),\n",
        "    'B': (-1,-1),\n",
        "    'C': (0,2),\n",
        "    'D': (0,0),\n",
        "    'E': (0,-2),\n",
        "    'F': (1,1),\n",
        "    'G': (1,-1),\n",
        "    'H': (2,0)\n",
        "}\n",
        "start = 'A'  # ì‹œì‘ ì •ì \n",
        "goal = 'H'   # ëª©í‘œ ì •ì \n",
        "\n",
        "# Best-First Search ì‹¤í–‰\n",
        "path = best_first_search(graph, start, goal)\n",
        "print(\"Path:\", path)\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™”\n",
        "draw_graph(graph, path, pos)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "\n",
        "\n",
        "---\n",
        "\n"
      ],
      "metadata": {
        "id": "QbXEQIRBCZNw"
      },
      "id": "QbXEQIRBCZNw"
    },
    {
      "cell_type": "markdown",
      "id": "83cd7f3a-7b09-400b-8dcc-7d6a286f5cc7",
      "metadata": {
        "id": "83cd7f3a-7b09-400b-8dcc-7d6a286f5cc7"
      },
      "source": [
        "# [ì°¸ê³ ] A* Algorithm"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "cdf4f59d-08ae-418c-afcb-6f9d7a9618cc",
      "metadata": {
        "id": "cdf4f59d-08ae-418c-afcb-6f9d7a9618cc"
      },
      "outputs": [],
      "source": [
        "# íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ (ì„ì˜ì˜ ê°’ì„ ì‚¬ìš©í•œ ì˜ˆì‹œ)\n",
        "def a_star_search(graph, start, goal):\n",
        "    open_set = []\n",
        "    heapq.heappush(open_set, (0, start))\n",
        "\n",
        "    came_from = {}\n",
        "    g_score = {node: float('inf') for node in graph}\n",
        "    g_score[start] = 0\n",
        "\n",
        "    f_score = {node: float('inf') for node in graph}\n",
        "    f_score[start] = heuristic(start, goal)\n",
        "\n",
        "    while open_set:\n",
        "        _, current = heapq.heappop(open_set)\n",
        "\n",
        "        if current == goal:\n",
        "            return reconstruct_path(came_from, current)\n",
        "\n",
        "        for neighbor, weight in graph[current].items():\n",
        "            tentative_g_score = g_score[current] + weight\n",
        "            if tentative_g_score < g_score[neighbor]:\n",
        "                came_from[neighbor] = current\n",
        "                g_score[neighbor] = tentative_g_score\n",
        "                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)\n",
        "                if neighbor not in [i[1] for i in open_set]:\n",
        "                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n",
        "\n",
        "    return None\n",
        "\n",
        "def reconstruct_path(came_from, current):\n",
        "    total_path = [current]\n",
        "    while current in came_from:\n",
        "        current = came_from[current]\n",
        "        total_path.append(current)\n",
        "    total_path.reverse()\n",
        "    return total_path\n",
        "\n",
        "\n",
        "# A* ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰\n",
        "path = a_star_search(graph, start, goal)\n",
        "if path:\n",
        "    print(\"Path found:\", path)\n",
        "else:\n",
        "    print(\"No path found.\")\n",
        "    path = []\n",
        "\n",
        "# ê·¸ë˜í”„ ì‹œê°í™”\n",
        "draw_graph(graph, path, pos)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "807733c5-d5e4-4b6f-abfe-e1c4bb6cb7d6",
      "metadata": {
        "id": "807733c5-d5e4-4b6f-abfe-e1c4bb6cb7d6"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.1"
    },
    "colab": {
      "provenance": [],
      "toc_visible": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}